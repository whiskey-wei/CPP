#问题描述

有时，线程需要等待某事件发生，比如一个条件变为true，或者某任务被另一个线程完成。
例如，我们创建一个基于网络的应用程序，处理如下的任务：

1、与处理器进行一些握手操作；
2、从xml文件load数据；
3、处理从xml文件load的数据.

可以发现，任务1不依赖其他的任务，而任务3则依赖于任务2，这意味着任务1和任务2可以由不同的线程并行运行，以提升程序性能。
因此，让我们将其分解成一个多线程的应用程序

现在，它包含2个线程，线程1的任务是：
·与服务器进行握手操作
·等待线程2从xml获取的数据
·处理从xml获取的数据


线程2的任务是：
·从xml获取数据
·通知另一个线程，即等待消息


#badslove
创建一个默认为false的boolean型全局变量，在线程2中将其设为true，线程1将会循环检测其值，一旦该值被设为true，线程1将会继续处理数据，
由于它是一个由两个线程共享的全局变量，需要使用mutex锁进行同步。
该方法存在以下缺陷：
为了检测变量，线程将会持续获取-释放锁，这样会消耗CPU周期并且使线程1变慢，因为它需要获取相同的锁来更新bool变量。
因此，显然我们需要一个更好的实现机制，如某种方式，线程1可以通过等待event信号来阻塞，另一个线程可以通知该event并使线程1继续。这将会有相同的CPU周期，并有更好的性能。

#goodslove
我们可以使用条件变量来实现，条件变量是一种用于在2个线程之间进行信令的事件，一个线程可以等待它得到信号，其他的线程可以给它发信号。

##条件变量
条件变量是一种用于在2个线程之间进行信令的事件，一个线程可以等待它得到信号，其他的线程可以给它发信号。
在c++11中，条件变量需要头文件：
condition_variable

同时，条件变量还需要一个mutex锁


条件变量实际上是如何运作的

  ·线程1调用等待条件变量，内部获取mutex互斥锁并检查是否满足条件；
  ·如果没有，则释放锁，并等待条件变量得到发出的信号(线程被阻塞)，条件变量的wait()函数以原子方式提供这两个操作；
  ·另一个线程，如线程2，当满足条件时，向条件变量发信号；
  ·一旦线程1正等待其恢复的条件变量发出信号，线程1便获取互斥锁，并检查与条件变量相关关联的条件是否满足，或者是否是一个上级调用，如果多个线程正在等待，那么      notify_one将只解锁一个线程；
  ·如果是一个上级调用，那么它再次调用wait()函数。


条件变量的主要成员函数是：
###Wait()
它使得当前线程阻塞，直到条件变量得到信号或发生虚假唤醒；
它原子性地释放附加的mutex，阻塞当前线程，并将其添加到等待当前条件变量对象的线程列表中，当某线程在同样的条件变量上调用notify_one() 或者 notify_all()，线程将被解除阻塞；
这种行为也可能是虚假的，因此，解除阻塞后，需要再次检查条件；
一个回调函数会传给该函数，调用它来检查其是否是虚假调用，还是确实满足了真实条件；
当线程解除阻塞后，wait()函数获取mutex锁，并检查条件是否满足，如果条件不满足，则再次原子性地释放附加的mutex，阻塞当前线程，并将其添加到等待当前条件变量对象的线程列表中。

###notify_one()
如果所有线程都在等待相同的条件变量对象，那么notify_one会取消阻塞其中一个等待线程。

###notify_all()
如果所有线程都在等待相同的条件变量对象，那么notify_all会取消阻塞所有的等待线程。
如何处理第六节讨论的带有条件变量的多线程情景呢？ 
